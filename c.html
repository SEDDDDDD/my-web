<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Programming Language</title>
        <link rel="stylesheet" href="./project/prolang.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link
            rel="preconnect"
            href="https://fonts.gstatic.com"
            crossorigin="crossorigin">
        <link
            href="https://fonts.googleapis.com/css2?family=Gothic+A1&display=swap"
            rel="stylesheet">
        <link rel="stylesheet" href="./prolang.css">
        <style>
            * {
                font-family: 'Gothic A1', sans-serif;
            }
        </style>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/gsap.min.js"
            integrity="sha512-cdV6j5t5o24hkSciVrb8Ki6FveC2SgwGfLE31+ZQRHAeSRxYhAQskLkq3dLm8ZcWe1N3vBOEYmmbhzf7NTtFFQ=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"></script>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/ScrollToPlugin.min.js"
            integrity="sha512-kSI9CgGh60rJbNVeMJvfNX0UTKAq8LEOea/yKJQbFpIroxT7bf9/zUFXbnfsQP5F6xlOOHtCfBPgsE1ceiHnRw=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"></script>
    </head>

    <body>
        <div id="goto-top">
            <div class="material-icons">
                <arrow_upward></div>
            </div>
            <script>
                const gotoTopEl = document.querySelector('#goto-top')
                window.addEventListener('scroll', function () {
                    if (window.scrollY > 500) {
                        gsap.to(gotoTopEl, .2, {x: 0})
                    } else {
                        gsap.to(gotoTopEl, .2, {x: 100})
                    }
                }, 300)
                gotoTopEl.addEventListener('click', function () {
                    gsap.to(window, .7, {scrollTo: 0})
                })
            </script>
            <header class="mainName"><div style="cursor:pointer" onclick="location.href='index.html';">
                Programming Language</div></header>
            <hr>
            <div class="navi">
                <div>
                    <button type="button" onclick="location.href='python.html'">1. Python
                    </button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
                    <button type="button" onclick="location.href='java.html'">2. Java
                    </button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
                    <button type="button" onclick="location.href='c.html'">3. C
                    </button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </div>
            </div>
            <hr>

            <div style="text-align:center">
                <img
                    style="height:120px" src="image/c.svg">
            </div>

            <nav class="mainDisplay">
                <section class="listStyle">

                    <div class="list">
                        <h2 id="main">목차</h2>
                        <br>
                        <span>
                            <a href="#s1">1.</a>&nbsp;개요
                            <br><br>

                            <a href="#s2">2.</a>&nbsp;설명
                            <ul>
                                <a href="#s2-1">2.1.</a>&nbsp;장점</ul>
                            <ul>
                                <a href="#s2-2">2.2.</a>&nbsp;단점</ul>
                            <ul>
                                <a href="#s2-3">2.3.</a>&nbsp;사용 분야</ul>
                            <ul>
                                <a href="#s2-4">2.4.</a>&nbsp;이식성</ul>
                            <ul>
                                <a href="#s2-5">2.5.</a>&nbsp;점유율과 플랫폼별 지원 현황</ul>
                            <ul>
                                <a href="#s2-6">2.6.</a>&nbsp;다른 프로그래밍 언어에 미친 영향
                                <ul>
                                    <a href="#s2-6-1">2.6.1.</a>&nbsp;&nbsp;
                                    <a href="https://namu.wiki/w/C%2B%2B">C++
                                    </a>와의 관계</ul>
                            </ul>
                            <ul>
                                <a href="#s2-7">2.7.</a>&nbsp;포인터</ul>
                        </span>
                        <span>
                            <a href="#s3">3.</a>&nbsp;C언어용 개발 도구들
                        </span><br><br>
                        <span>
                            <a href="#s4">4.</a>&nbsp;여담
                            <ul>
                                <a href="#s4-1">4.1.</a>&nbsp;C언어의 다음 언어?</ul>
                            <ul>
                                <a href="#s4-2">4.2.</a>&nbsp;Write in C</ul>
                        </span>
                    </div>
                </section>
                <article class="center">
                    <div id="s1">
                        <br>
                        <strong class="Sname">
                            <a href="#main">1.</a>
                            개요</strong><br>
                        <hr>
                        <p>
                            <div class="normalBox">
                                #include
                                <stdio.h><br>
                                    <br>
                                    <strong style="color:blue;">int</strong>
                                    main(<strong style="color:blue;">int</strong>
                                    argc,
                                    <strong style="color:blue;">char</strong>** argv) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;printf(<strong style="color:orange;">"Hello world"</strong>);<br>
                                    }
                                </div>
                            </p>
                            <p>
                                <div class="specialBox">
                                    The computing world has undergone a revolution since the publication of The C
                                    Programming Language in 1978.<br>
                                    1978년 책 "The C Programming Language" 출판 이후 컴퓨팅 세계는 혁명을 겪어왔다.<br><hr>
                                    - The C Programming Language 2nd Edition
                                </div>
                            </p>
                            <p>
                                1972년에 벨 연구소(Bell Labs)의 데니스 리치가 만든 프로그래밍 언어. 원래 명칭은 그냥 'C'지만 한국에서는 표제어에서도 볼 수
                                있듯 'C언어'라는 명칭으로 주로 부른다. 세계적으로 많이 쓰이는 프로그래밍 언어 중 하나이다.
                            </p>
                            <p>
                                온라인 상으로 코드를 실행시켜 보고 싶다면
                                <a style="color:green" href="https://repl.it/languages/c">여기</a>로.
                            </p>
                        </div>
                        <div id="s2">
                            <br>
                            <strong class="Sname">
                                <a href="#main">2.</a>
                                설명</strong><br>
                            <hr>
                            <p>
                                C의 정신은 C99 Rationale에서 다음과 같이 묘사하고 있다.
                            </p>
                            <p>
                                <ul style="line-height:30px">
                                    <li>
                                        <strong>프로그래머를 믿어라. (Trust the programmer)</strong>
                                    </li>
                                    <li>프로그래머가 작업을 못하게 방해하지 마라. (Don't prevent the programmer from doing what needs
                                        to be done)</li>
                                    <li>언어를 작고 간단하게 유지하라. (Keep the language small and simple)</li>
                                    <li>명령을 실행하는 방법을 하나만 제공하라. (Provide only one way to do an operation)</li>
                                    <li>호환성은 장담할 수 없더라도 빨리 작동하게 만들어라. (Make it fast, even if it is not guaranteed to
                                        be portable)</li>
                                </ul>
                            </p>
                            <p>
                                첫 줄의
                                <strong>'프로그래머를 믿어라'</strong>
                                부분이 오늘날 다른 언어들과 가장 큰 차이를 불러오는 것이다. 오늘날 다른 고생산성 언어들이 프로그래머를 못 믿고 퍼포먼스 희생을 감수하고서라도
                                문제가 생길만한 부분들을 컴파일러 또는 가상머신에서 자동으로 처리해주거나
                                <a href="https://namu.wiki/w/Rust">프로그래머가 이상한 코드를 짜지 못하도록 엄격하게 컴파일</a>해준다면, C는 "믿을 테니까
                                <strong>알아서 해라</strong>." 한마디로 끝낸다.
                            </p>
                            <p>
                                C 언어 이전에도 고수준 언어들은 많이 존재했지만, 대부분 특정 어플리케이션 영역을 대상으로 하거나, 컴퓨터 과학 이론을 입증하기 위해 만들어진
                                실험실 언어들이었다.
                            </p>
                            <p>
                                어플리케이션 영역이 아닌 운영체제를 어셈블리어가 아닌 언어로 작성한다는 것은 당시엔 금기였다. 유닉스의 전신인
                                <a href="https://namu.wiki/w/%EB%A9%80%ED%8B%B1%EC%8A%A4">MULTICS</a>는 그 금기를 어기고
                                PL/1라는 고수준 언어로 작성하려고 시도했고, 망했다. 유닉스는 멀틱스에 대한 반성에서 단순하게 만드는 방향을 추구했으며, 그렇기에 이름부터가
                                UNI-로 시작하도록 지었다. C 언어와 유닉스는 소수의 예외를 제외하고 대부분을 C 언어로 작성하고서도 우려와는 달리 단점보다 장점이 훨씬
                                많다는것을 보이면서 이 금기에 정면으로 도전해서 승리하였다. 그리고 지금은 운영체제는 C 언어가 아니면 안된다는 새로운 금기가 생겼다. 이는
                                그동안 컴퓨터의 평균 성능이 놀랍게 발전했고, 운영체제 역시 초기와는 비교할 수 없을 정도로 커져 효율성이 중요하기 때문이기도 하다.
                            </p>
                            <p>
                                그래서 C는 처음부터 어셈블리어와 비교할만한 효율을 가지게 저수준으로 설계되었다. K&R의 "C programing language" 책의 초판
                                서문에서도 C를 어셈블리어를 대체하는 이식성 있는 어셈블리어 (portable assembler) 로 만드는 것을 목표로 설계되었음을 밝히고
                                있다.
                            </p>
                            <p>
                                그러나 현실적으로 바라본다면 C는 절대, 전혀, 이식성 있는 어셈블리어라고 할 수가 없다. 왜냐하면 기계와 직접적으로 상호작용하지 않기
                                때문이다. 순수한 C 문법만으로는 CPU 레지스터, CPU 캐시, I/O 포트, 페이지 테이블, 스택 프레임, 버스, USB, RAM 등
                                하드웨어와 어떤 방식으로도 직접적으로 접근할 수 없다. 프로그램이 다루는 것은 대상체와 값일 뿐이며 프로그램 소스 코드가 기계어로 직역되지도
                                않는다. C도 엄연히 추상화된 언어이며 어셈블리어의 동작과는 다소 차이가 있다. C 표준에 의해 정의되는 추상 상태 기계에서 해당 프로그램을
                                실행시켰을 때 발생하는 결과를 흉내낼 수 있도록 해당하는 아키텍처에서의 기계어 프로그램을 만들어내는 것은 C 언어가 아니라 C 컴파일러이다.
                                이것을 이해하지 못하는 프로그래머들이 왜 int x; if (x + 1 < x) 같은 코드가 의도된 동작을 하지 못하는지를 깨닫지 못하는
                                것이다. C와 다른 언어가 다른 점은, C의 경우 C 표준이 정의하는 추상 상태 기계가 상상할 수 있는 모든 하드웨어에서 효율적이고 포터블한
                                구현을 허용할 수 있도록 추상 레이어가 최소한도로 정의되어 있다는 것이다. 애초에 기계어에 가까웠으면 컴파일러의 최적화라는 개념 자체가 있을수가
                                없었다.
                            </p>
                            <p>
                                그런데 이러한 점들이 오히려 이식성에 큰 영향을 끼쳤다고 볼 수도 있는데 하드웨어에 직접 접근하지 못하므로 하드웨어에 의존적인 기능들은 사용하지
                                않게 되었고 구현체의 추상화 레이어가 기계별로 다른 동작을 일관화시켰기 때문이다. 다만 이 점은 여러 컴파일러가 성능 경쟁을 하고 하드웨어 발전
                                속도가 빨라진 지금에는 그리 타당성 있다고 볼 수는 없다.
                            </p>
                            <p>
                                개발 당시의 고수준 언어로는
                                <a href="https://namu.wiki/w/%EC%BD%94%EB%B3%BC">코볼</a>,
                                <a href="https://namu.wiki/w/%ED%8F%AC%ED%8A%B8%EB%9E%80">포트란</a>이 주로 쓰였는데, 이들은
                                <a href="https://namu.wiki/w/%EC%B2%9C%EA%B3%B5%20%EC%B9%B4%EB%93%9C">천공 카드</a>가
                                쓰이던 시절 만들어져서 문법이 매우 불친절하다. 그리고 코볼은 원래는 프로그램 코드가 업무 서류로도 사용이 가능하도록(!) 설계가 돼있어서
                                그렇다. 주석이 코드고 코드가 주석일 경우의 아주 나쁜 사례. C는 이런 당대 고수준 언어들에 비해 매우 이해가 가기 쉬운 문법을 사용하여
                                초보자가 쉽게 접근할 수 있었다.
                            </p>
                            <p>
                                <a href="https://namu.wiki/w/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4">어셈블리 코드</a>를 코드 안에 집어넣어서 구동 속도 면에서 이점을 얻을 수도 있다(그러나 호환성이 낮아진다.). 인라인 어셈블러가 이를 가능케 해 준다.
                            </p>
                            <p>
                                C 언어는
                                <a href="https://namu.wiki/w/%EC%9C%A0%EB%8B%89%EC%8A%A4">유닉스</a>를 만들기 위한 언어로 시작했기 때문에 유닉스의 표준인
                                <a href="https://namu.wiki/w/POSIX">POSIX</a>와도 관련이 깊고, 결국 C를 표준으로 공부하려면 현 시점에서는 성능이 우수하고 표준을 엄격하게 따르는
                                <a href="https://namu.wiki/w/GCC">GCC</a>나
                                <a href="https://namu.wiki/w/LLVM">LLVM</a>/<a href="https://namu.wiki/w/Clang">Clang</a>을
                                <a href="https://namu.wiki/w/Linux">리눅스</a>와 조합하여 사용하는 것이 가장 낫다. 리눅스는 유닉스와 같은 뿌리를 공유하며 POSIX 표준 역시 따르고 있기 때문이다. 최소한
                                <a href="https://namu.wiki/w/Visual%20Studio">Visual Studio</a>는 사용하지 않는 것이 좋다.
                                Visual Studio에 통합되어 있는 MSVC 컴파일러는 C99의 가변길이 배열조차 지원하지 않을 만큼 C언어 지원이 부족하기 때문이다.
                                윈도우 사용자라 하더라도 과거에 비해 리눅스를 사용하기가 한결 수월해졌는데,
                                <a href="https://namu.wiki/w/Windows%2010">Windows 10</a>부터는 Windows Subsystem for Linux(<a href="https://namu.wiki/w/WSL(Windows)">WSL</a>)라는이름으로리눅스 서브시스템이 추가되었기 때문이다. 무거운 가상머신인 Cygwin을 써야 했던 시절을 생각하면 훨씬 상황이 좋아진 것. 특히GCC,LLVM/Clang은 #pedantic -Wall -Wextra -Werror 컴파일 옵션을 넣으면 사소한 경고 사항도 전부 에러로변환하여컴파일을 중단시키므로 코드의 품질을 잡는 데 많은 도움이 된다.
                            </p>
                            <p>
                                <a href="https://namu.wiki/w/%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD">대한민국</a>에선 많은 곳이 C로 공부를 시작하며 나머지는
                                <a href="https://namu.wiki/w/C%2B%2B">C++</a>,
                                <a href="java.html">Java</a>,
                                <a href="https://namu.wiki/w/C%23">C#</a>,
                                <a
                                    href="https://namu.wiki/w/%EB%B9%84%EC%A3%BC%EC%96%BC%20%EB%B2%A0%EC%9D%B4%EC%A7%81">비주얼 베이직</a>,
                                <a
                                    href="https://namu.wiki/w/%EC%96%B4%EB%8F%84%EB%B9%84%20%ED%94%8C%EB%9E%98%EC%8B%9C">어도비 플래시</a>
                                (<a
                                    href="https://namu.wiki/w/%EC%95%A1%EC%85%98%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8">액션스크립트</a>) 등이 차지하고 있다. 즉 독점에 가까운 위치를 점유하고 있다. 이는 각
                                <a href="https://namu.wiki/w/%EB%8C%80%ED%95%99">대학</a>
                                혹은 학원들의 커리큘럼 탓이 가장 크다고 볼 수 있는데, 이 때문에 아직도 '자바 먼저' vs 'C 먼저'의 떡밥은 개발자들 사이에서 좋은
                                키배거리가 되고 있다. 그러나 후술할 듯 C가 미친 영향은 Java를 포함해서 매우 광범위한지라 어떻게 해도 결국 C가 맨 앞에 선다.
                                <a href="https://namu.wiki/w/%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD">대한민국</a>의
                                <a
                                    href="https://namu.wiki/w/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99%EA%B3%BC">컴퓨터과학과</a>
                                학부 과정에서는 이게 프로그래밍 언어의 기초 취급을 받고 있다. C언어 자체의 난이도는 위에서 봤듯이 무시할 게 못 된다. 그럼에도 C를 먼저
                                권유하는 입장은 간단하다. 컴퓨터 아키텍처 및 시스템 프로그래밍, OS를 배우기 위해선 C언어(+
                                <a href="https://namu.wiki/w/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4">어셈블리어</a>
                                조금)만한 게 없기 때문이다.
                                <a href="java.html">Java</a>
                                등의 고수준 언어는 추상화 레이어가 여러 OS 및 아키텍처 개념들을 가리고 있어서, C++는 다양한 멀티 패러다임을 언어에 집어넣느라 복잡한
                                문법이 많아져서 low-level한 직관을 얻기 힘들다.
                            </p>
                            <p>
                                C언어 자체는 지원되는 기능이 적고 문법이 간단하다.
                                <a
                                    href="https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">객체 지향 프로그래밍</a>(OOP)이나
                                코루틴, 클로저, 메타 프로그래밍 등 고수준의 기능들을 지원하는 언어들과 비교하면 특히나 그렇다. 550쪽 정도밖에 안 되는 C언어 표준에서도
                                순수 문법 부분은 200쪽 정도밖에 안 되며 나머지는 다 라이브러리 관련 부분이고, 함수의 개수로 치면 고작해야 150개 근처이다. 수천 개나
                                되는 기본 라이브러리를 지원하는 다른 언어들과 비교하면 정말 작고 간단하다. 초반의 포인터 장벽만 넘는다면 문법 자체를 마스터하고 간단한
                                커맨드라인 프로그래밍을 할 수 있는 수준까지는 엄청 쉽다.
                            </p>
                            <p>
                                하지만 기능이 적다고 결코 쉬운 건 아니다. 프로그래밍을 할 때 지원하는 기능이 적다고 그 적은 기능만 쓸 수는 없다. 따라서 기본
                                라이브러리에서 지원하지 않는 기능은 결국 프로그래머가 직접 구현해서 써야 하는데, 1970년대 이후 프로그래밍 언어계에서 오늘날 영어와 같은
                                위치를 차지하고 있던 덕분에 그런 기능의 구현이나 최적화에 관한 많은 트릭들이 존재하고 이것을 얼마나 많이 알고있는가가 사실 C언어의 핵심이다.
                            </p>
                            <p>
                                오늘날 고수준 언어들이 다수의 프로그래머가 함께 개발하는 것을 염두에 두고 팀에 누가 될 만한 위험하거나 생산성에 저해되는 부분들을 언어
                                차원에서 강제로 제외시키는 경향이 있다면, C언어는 이런 부분을 완전히 개방했다. 초기 C언어는 커다란 규모의 프로그램을 거의 염두에 두지 않고
                                개발되었다. 당시 IBM 메인프레임에 사용되던 System/360이 수천 명의 프로그래머가 달라붙어 어셈블리어로 수백 만 줄이었는데, C언어로
                                만들어진 가장 큰 프로그램인 초창기 유닉스의 커널은 고작 만 줄 정도였다. 상황이 이렇다보니 같은 프로그램이라도 프로그래머의 지식 수준과 능력에
                                따라 퀄리티 차이가 그야말로 극과 극으로 벌어지는 언어이다.
                                <a href="https://namu.wiki/w/Linux">리눅스</a>
                                등 C언어로 작성된 대규모 오픈소스 프로젝트를 보면 C언어 활용의 예술을 볼 수 있다. 방대한 양의 코드를 함수, 구조체, 포인터, 매크로만을
                                이용해서 철저히 모듈 단위로 잘 관리하고 있다.
                            </p>
                            <p>
                                어떤 언어든 그 실력을 충분히 발휘하려면 주로 쓰이는 분야에서 사용하게 되는 기술을 익혀야 하는데, C언어의 주 사용 분야라는 것이 하필 기계
                                제어. 제대로 사용하려면 프로그래머들이 보통 싫어하는 하드웨어와 어셈블리어에도 결국 손을 대야 한다.
                            </p>
                            <p>
                                C는 작지만
                                <a href="https://namu.wiki/w/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4">어셈블리어</a>
                                다음으로 기계 레벨까지 접근 가능하고, 충분히 강력한 언어이기 때문에 C의 힘을 제대로 발휘하려면 어셈블리어 수준으로 프로그래밍해야 하고
                                하드웨어의 기능을 꿰어차고 있어야 한다. 오죽하면 C가 '시스템 독립적인 어셈블리(System Independent Assembly)'라 불릴
                                정도. 애초에 C 자체가 운영체제를 만들기 위해 고안된 언어이니만큼 그럴 수밖에 없었다.
                            </p>
                            <p>
                                일반적인 프로그래밍도 역시 가능하지만, 그런 용도로는 더 적합한 언어들이 널려있다. 2010년대 부터는 데스크톱 애플리케이션보다 웹, 스마트폰
                                애플리케이션의 활용도가 높아져서, 하드웨어 컨트롤이 중요한 분야가 아니면 C를 써야 할 이유가 거의 없다. 즉, 초심자가 C언어를 배우는
                                것까지는 문제가 없지만 배우고 나서 뭔가 제대로 할만한 건 사실상 없다. 그리고, 바로 그렇기 때문에 프로그래밍 입문용 언어의 자리도 해외
                                기준으로는 대부분
                                <a href="java.html">Java</a>나
                                <a href="python.html">Python</a>으로 대체되었다. 또한 데스크톱 애플리케이션도
                                <a href="https://namu.wiki/w/HTML">HTML</a>/<a href="https://namu.wiki/w/CSS">CSS</a>/<a href="https://namu.wiki/w/JavaScript">JavaScript</a>를 이용하는 Electron 프레임워크가 나오면서 예전보다 개발이 훨씬 쉬워졌다.
                            </p>
                            <div id="s2-1">
                                <br>
                                <strong class="Sname">
                                    <a href="#main">&nbsp;&nbsp;2.1</a>
                                    장점</strong><br>
                                <hr>
                                <p>
                                    C로 짜여진 코드는 속도가 빠르고 바이너리 크기도 작아 속도가 다른 무엇보다 (심지어는 생산성보다도) 중요한 임베디드 혹은 모바일 계열, 또는
                                    시스템 프로그래밍 등에서 주로 쓰인다.
                                </p>
                                <p>
                                    프로그램의 규모가 커질 경우 C언어로 작성해서 얻을 수 있는 파일의 규모는 Python보다 훨씬 작다. 과거에는 메모리 가격이 비쌌던 만큼
                                    메모리를 적게 잡아먹는 프로그래밍 기법을 선호했으며, 화성 탐사선도 이러한 점을 반영하여 C언어로 만든 프로그램을 사용했다.
                                </p>
                                <p>
                                    이러저러한 고급 언어들이 나오는 상황에서도 아직 저수준의 제어를 위해 C가 필요한 경우도 많다. 예를 들어, OS를 만든다면 아무리 생산성을
                                    고려한다고 해도 시스템 제어 측면과 OS의 기능 위에서 돌아가는 애플리케이션 때문에라도 속도라는 면은 중요하고, 그렇다고 속도를 높이기 위해
                                    어셈블리어나 기계어로만 OS를 짜기에는 생산성이 매우 낮아지니, 타협점으로 C를 쓴다. 물론 시스템 콜 인터페이스나 ABI, 인터럽트, 부트
                                    스트랩, 드라이버 등 머신에 직결된 부분에는 어셈블리나 기계어를 사용해야 한다. 아니면 머신 제조업체가 제공하는 라이브러리를 사용하거나. 최근
                                    C/C++ 수준의 기계제어와 안전한 메모리 관리를 동시에 제공하는
                                    <a href="https://namu.wiki/w/Rust">Rust</a>라는 언어가 새로 나오기는 했지만, C와 C++는 원체 레거시가
                                    오랫동안 유지되는 성향이 강해서 Rust가 메이저로 부상하기는 쉽지 않은 상황이다.
                                </p>
                                <p>
                                    또한 대부분의 운영체제가 제공하는
                                    <a href="https://namu.wiki/w/API">API</a>/시스템 콜은 C 기반이므로, 이를 직접 사용하려면 어찌되건 C를
                                    래핑하는 방식으로밖에 쓸 수 없다. 그 외에 임베디드 시스템에서 단가 문제로 시스템 처리 능력과 메모리 제한이 매우 심각한 경우가 많은데, 이
                                    경우도 C가 그나마 적합하다. 옛 시절 어셈블리어가 차지했던 자리를 현재는 C가 차지하고 있다고 봐도 된다. 이렇게 활용되는 부분이 많으므로
                                    당분간 C가 사장될 가능성은 없다. 게다가 막대한 분량의 레거시 코드도 있고. 실제로 프로그래밍 언어 점유율 조사에서 한때 자바를 제치고 1위를
                                    차지한 적도 있는 것을 보아서는 당분간 현역으로 왕성하게 활동할 것으로 보인다. 물론 이건 C의 점유율이 늘어났다기보다는 타 현대적인 언어들
                                    덕분에 자바의 점유율이 줄어든 것이지만.
                                </p>
                                <p>
                                    안정성보다는 퍼포먼스를 골수까지 극한으로 뽑아내야 하는 게임 프로그래밍 분야 또한 C/C++가 대세. 게임 프로그래머들이 C에서 C++로
                                    넘어가기를 끝까지 싫어했던 것은 오로지 C(지금은 C++)가 다른 언어보다 속도를 빠르게 최적화할 수 있다는 생각 때문이며, 그래서 다른
                                    분야보다 보수적이라는 소리를 듣는 편이다. 그러나 요즘에는
                                    <a href="https://namu.wiki/w/%EB%AA%A8%EB%B0%94%EC%9D%BC%20%EA%B2%8C%EC%9E%84">모바일 게임</a>
                                    시장이 급속하게 커지면서, 코어 부분만 C/C++로 만들고 그 외의 상당 부분은
                                    <a href="python.html">Python</a>,
                                    <a href="java.html">Java</a>,
                                    <a href="https://namu.wiki/w/C%23">C#</a>
                                    등의 고생산성 언어로 대체하는 경우가 늘어나고 있다.
                                </p>
                                <p>
                                    현시점에서 C의 가장 큰 의의는 사실상 모든 아키텍처와 운영체제에서 가상머신 등의 추가적인 단계 없이 네이티브로 지원하는 언어라는 것이다.
                                    C++는 지원하지 않더라도 C는 지원하는 것이 보통이다. 워낙 널리 쓰이다보니 CPU 디자이너들이 가장 먼저 하는 일은 C언어를
                                    instruction set으로 포팅하는 것일 정도다. 심지어 C언어 설계 자체가 CPU 인스트럭션 설계에 영향을 주는 단계에 이르렀다. 그런
                                    관계로 이식성이 중요한 경우는 대개 C를 사용한다. 자바의 멀티플랫폼과는 성격이 다르다. 자바는 각 플랫폼용으로 만들어진 가상머신 위에서 같은
                                    소스가 실행되는 것이고, C는 각 시스템에 맞는 기계어로 컴파일되는 것이다. 위에도 언급했던 자바 가상머신 자체가 C로 만들어져 있으므로 당연히
                                    자바보다 범위가 넓다. 기존 C 프로그래머들은 진정한 멀티 플랫폼 언어는 자바가 아니라 C 라고 믿는 사람도 부지기수. 표준만 철저하게 지킨 C
                                    코드는 C 컴파일러가 있는 어떤 플랫폼에서도 컴파일 - 실행이 가능하다. 그게 쉽지 않아서 문제지. 요즘 C를 사용하는 이유는 위에도 쓰여
                                    있듯이 저수준 제어인데, 이는 플랫폼에서 제공하는 API를 사용하지 않고는 불가능하다. 이런 특성상 런타임의 관점에서 보면 Rust,
                                    Python, Java, C++ 등의 사실상 거의 모든 언어의 런타임들부터가 C 런타임에 의존하고 있다.
                                </p>
                                <p>
                                    이렇게 이미 한물 간 언어처럼 보이지만, 여전히 '프로그래밍' 입문으로 C를 추천하는 사람이 많다. 사실 이 말에도 일리가 있긴 한 것이,
                                    C라는 언어는 매우 심플하면서도 배우는 과정에서 소프트웨어 구성의 최소 단위인 비트부터 시작해서 메모리 관리, 그리고 고급 개념인 OOP
                                    비스무리한 것까지 흉내내면서 소프트웨어 전반을 훑게 되고, C를 배우면서 나오는 과제들은 커맨드 라인에서 이미 쓰이고 있는 기본적인 툴을
                                    'reinvent the wheel' 하는 식의 과제들이 많으므로 바닥부터 훑어가며 견문을 넓히는 데 좋다. 실제로 가장 기저에 놓인 OS
                                    API는 오늘날 플랫폼을 불문하고 거의 다 C언어로 되어 있고, 그 외에도 대부분의 인프라가 되는 소프트웨어는 C로 만들어진 후 타 언어로의
                                    바인딩을 제공하는 식이다. 로우레벨부터 단계를 높여가며 관찰을 해보면, 머신코드는 머신에 따라 달라지고, 어셈블리어도 Intel/AT&T 등
                                    문법에 따라 몇 가지 버전이 존재하지만, 그 위쪽에서 결국 C 언어로 대통합이 이루어진다. 그리고, C 언어 위쪽으로 가면 다시
                                    C++/Java/C#/Objective-C/Python 등으로 다양하게 갈라진다. 즉, 두개의 원뿔을 꼭짓점끼리 붙여놓은 형태이며, 저 꼭짓점
                                    부분에 C 언어가 존재하는 형태이니, 이것만으로도 C언어의 중요성은 충분히 알 수 있다. 그래서 이런 견문은 실제로 나중에 더 이상 C언어를
                                    쓰지 않고 타 고급언어로 넘어가더라도 유용한 경우가 많다. (실제로, 많은 수의 언어가 C언어와의 FFI를 제공한다.)
                                </p>
                                <p>
                                    하드웨어나 컴퓨터 아키텍처를 배우게 된다면, C언어의 특징은 오히려 장점이 된다. Java나 Python 같은 언어들은 일반적인 상황에서
                                    생산성을 높이기는 좋지만 특정한 상황에서 속도를 높이기는 어렵다. 일반적인 개발을 하려면 많은 상황을 처리할 수 있도록 강력하고 복잡하게
                                    만들어야 하기 때문이다. 따라서 고성능이 필요한 특정 목적이 필요할 경우 언어에서 쌓은 추상화의 장벽을 뚫고 저수준(low level) 개념을
                                    이용할 필요가 있는데, 이에 관한 개념을 제대로 이해하려면 처음부터 OS와 기계제어를 위해 태어난 C언어를 사용하는 것이 가장 효과적이다. 다시
                                    말해, C언어를 공부한다는 말은 곧 하드웨어를 공부한다는 말과 같다고 할 수 있다.
                                </p>
                            </div>
                            <div id="s2-2">
                                <br>
                                <strong class="Sname">
                                    <a href="#main">&nbsp;&nbsp;2.2</a>
                                    단점</strong><br>
                                <hr>
                                <p>
                                    <strong>성능</strong>이라는 대명제에 충실해서 작게는 변수 초기화, 배열 범위 점검, 널 포인터 문제에서부터 크게는
                                    <a href="https://namu.wiki/w/%EC%93%B0%EB%A0%88%EA%B8%B0%20%EC%88%98%EC%A7%91">쓰레기 수집</a>(Garbage
                                    Collection; GC), 예외처리 같은 것까지 조금이라도 하드웨어에 오버헤드가 걸릴 것 같은 기능은 다 무시한 (그래서 프로그래머가 그런
                                    거까지 다 신경 써야 되는), 주니어 프로그래머에게는 힘든 언어다.
                                </p>
                                <p>
                                    현재 쓰이는 고수준 개념들 자체는 의외로 오래된 경우가 많다. 예를 들어서
                                    <a href="https://namu.wiki/w/%EC%93%B0%EB%A0%88%EA%B8%B0%20%EC%88%98%EC%A7%91">쓰레기 수집</a>은
                                    1959년에 최초로 구상되었고, 타입 에러를 컴파일 타임에 모두 잡아낼 수 있는 Hindley-Milner 타입 인터페이스가 1970년대 후반에
                                    나와서
                                    <a href="https://namu.wiki/w/Haskell">Haskell</a>
                                    등지에서 쓰이고 있다.
                                    <a href="https://namu.wiki/w/%ED%81%B4%EB%A1%9C%EC%A0%80">클로저</a>
                                    개념도 1960년대~70년대에 나왔다. 시간상으로는 지원한다 해도 이상하지 않다. 그럼에도 이런 기능을 C89/C90가 지원하지 않았던 이유는,
                                    당시 언어에 고수준 개념을 구현하기에는 하드웨어의 성능이 절대적으로 떨어졌다는 점이다. C언어가 컴파일러를 거쳐 기계어 파일이 나오면 그걸 다시
                                    사람이 직접 최적화를 해줘야 했다. 당시 컴파일러의
                                    <a
                                        href="https://namu.wiki/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%20%EC%B5%9C%EC%A0%81%ED%99%94">프로그램 최적화</a>
                                    성능이 떨어졌던 이유도 있겠지만, 당시 하드웨어는 초고도로 최적화를 하지 않으면 만족할 만한 속도가 나오지 않았다. 그래서 그 당시에는
                                    프로그래머라면 저런 부분은 알아서 관리해가며 쓰는 것이
                                    <strong>기본</strong>이었다.
                                </p>
                                <p>
                                    어셈블리어보다 호환성이 좋다고는 하지만, 하드웨어마다 달라지는 부분들을 언어 내에서 컨트롤해서 일관성을 유지하는 것이 아니라, 성능을 위해서
                                    전혀 후처리를 하지 않고 그대로 프로그램에 반영해버리므로 사실 C언어의 호환성도 미신이라는 사람들이 많다. 그대로 때려박는 특성상 컴퓨터
                                    아키텍처가 다르면 똑같게 동작할 리 없다는 것이 이유다. 그나마, C99에서는 컴퓨터 성능이 좀 올라간 것을 반영해서 여러가지 엣지케이스에 대해
                                    어느 정도 통일성을 만들려고 한 노력이 엿보이긴 한다.
                                </p>
                                <p>
                                    다음은 C언어 사용 시에 어려움을 느끼기 쉬운 부분들이다.
                                </p>
                                <p>
                                    <ul style="line-height:25px">
                                        <li>느슨한 타입 검사. 초창기의 K&R C와 비교하면 ANSI C부터 타입검사가 비교적 양호해졌지만, 아직도 서로 다른 종류의 포인터끼리의
                                            대입조차 가능하다. 사실 느슨한 타입 검사 자체가 나쁜 건 아니고 최신 언어들은 느슨한 타입 검사를 채용하는 언어가 많은데, 문제는 느슨한 타입
                                            검사를 통과한 타입 미스매치가 실행 시에 치명적인 문제를 일으킬 수 있다.</li>
                                        <br>
                                        <li>배열에 접근할 때, 인덱스가 배열 범위를 벗어나도 이를 체크하지 않는다. 이는 C언어에서 배열을 경계가 정해진 추상적인 자료구조로
                                            취급하는 게 아닌, 연속적인 메모리 뭉치의 첫 부분을 가리키는 포인터로 다루어서 일어난다. 이 때문에 '구조체 핵(struct hack)'이라는
                                            변태같은 짓도 가능한데, 그 예로 구조체 #struct _EE_PACKET 에서 앞부분의 데이터는 #int cnt; int checksum;
                                            int magic; 3개의 int형 변수를 가지며 당연히 이들의 자료형 크기는 변하지 않는다. 하지만 이 구조체 바로 뒷부분에 다수의
                                            #struct _EE_EE의 구조체 데이터가 붙어 오게 되며 몇 개가 있는지는 _EE_PACKET 구조체 내부의 cnt에 의해 정해진다. (즉,
                                            가변이다.) 이러한 경우 뒤의 _EE_EE 구조체 데이터에 접근하기 위해서는 #struct _EE_EE *EE = (struct _EE_EE
                                            *)(((struct _EE_PACKET *)packet_ptr) + 1); 와 같이 할 수도 있지만, _EE_PACKET의 제일 뒷부분에
                                            #struct _EE_EE EE[0]; 을 넣어 주고 #struct _EE_EE *EE = &packet_ptr->EE[0]; 처럼 할 수도
                                            있다. zero-sized array나 구조체 내의 변수선언부분의 제일 뒤라면 선언해도 문제가 되지는 않는다. 이 트릭은 웬만한 (제대로 된)
                                            C 교재라면 대부분 다루고 있다. 참고로, ANSI C 에서는 zero-sized array를 보장하지 않아 과거에는 주로 더미값을 사용했는데,
                                            이 트릭이 워낙 자주 쓰이다 보니 gcc 등 C 컴파일러들은 저 트릭을 위해 자체적으로 zero-sized array 를 따로 허용을 하였고,
                                            결국 C99에 와서 flexible array member 라는 이름으로 표준화가 되었다. 이렇게 배열 범위를 체크하지 않는다는 점은 심각한
                                            보안 구멍을 만들어낸다. 일명
                                            <a
                                                href="https://namu.wiki/w/%EB%B2%84%ED%8D%BC%20%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C">버퍼 오버플</a>로 취약점이라고도 하는데, 배열 체크를 하지 않는 C언어 때문에 생기는 보안상의
                                            <a href="https://namu.wiki/w/%EB%A7%8C%EC%95%85%EC%9D%98%20%EA%B7%BC%EC%9B%90">만악의 근원</a>.
                                            물론 프로그래머가 꼼꼼히 체크하면 되긴 하는데 인간 프로그래머는 항상 실수를 한다(...). 따라서 언어 자체에 내재한 취약점이라 볼 수 있다.</li>
                                        <br>
                                        <li>문자 처리 과정에서 실수가 있으면, 치명적 문제가 생길 수 있다. C에서는 문자열의 끝을 표시하기 위해 모든 비트가 0인 널(null,
                                            \0) 문자를 맨 마지막에 달아 사용하는데, 문자열을 처리하는 과정에서 이 널 문자를 잘못 달아주는 실수를 프로그래머가 저지르기 쉽다. 이런
                                            경우, 메모리의 경계를 넘어 다른 영역에 접근하는 치명적인 문제가 생긴다. 비교삼아 다른 언어의 문자열 처리 방식을 살펴보자면, 파스칼과 같은
                                            언어는 문자열의 길이를 맨 앞에 따로 저장하여 처리한다.</li>
                                        <br>
                                        <li>문자와 문자열을 숫자 또는 숫자의 배열로 취급한다. char 타입은 실제로는 1바이트 (C언어 스펙상으로는 반드시 1바이트가 8비트일
                                            필요는 없다.) 크기의 숫자 타입이고, 'A'와 같은 문자 상수(integer character constant)들은 실제로는 그냥
                                            int형이다. 따라서 int i='a'; char c = 'b' + i; 같은 식들이 매우 자연스럽다. 이와 비슷하게 문자열 (정확히는
                                            string literal)은 그냥 char 형 배열로 쓴다. 문자열 값의 끝에 붙는 널문자 '\0' 역시 int형 값으로 그냥 0 이다.</li>
                                        <br>
                                        <li>문자열 타입이 따로 없어서 문자형 배열을 대신 사용한다. 그 덕분에 문자열 처리가 까다로우며, 초보자들이 잘못 이해하거나 혼란을 느끼기가
                                            쉽다. 주로 문자열 상수에 대해 잘못 이해하는 경우가 많은데, 문자열 상수 자체는 '문자열'이나 '값' 자체가 아닌 '배열'이며, 결과적으로는
                                            해당 배열의 첫번째 글자가 저장된 위치를 가리키는 '주소값'이 된다. 초보들은 #char * s를 문자에 대한 포인터가 아닌 문자열에 대한
                                            포인터로 잘못 이해하여 s가 가리키고 있는 '문자열'을 가져오기 위해 s에 참조 연산자 *를 붙이는 경우가 있는데, 이렇게 하면 의도한 대로
                                            원래의 문자열 전체를 가져올 수 없다. 다른 타입들에 대해서는 예를 들어 #int i, *j = &i; *j = 3; 식으로 해당 포인터가
                                            가리키는곳에 있는 '값'을 의미할때는 항상 * operator 를 붙여줘야 하지만, 문자열 전체일 경우에는 참조 연산자 *를 바로 쓰지 않고
                                            #char *s; s = "Hello"; 처럼 구분해서 써야 한다. *s 는 s[0] 과 마찬가지로 문자 'H'의 값 그 자체를 의미하기
                                            때문이다.</li>
                                        <br>
                                        <li>대입 (=) 연산자가 값을 반환한다. 가장 흔한 실수로 == 를 쓸 곳에 = 를 하나만 찍는 오타를 범했을 경우, integer 값이
                                            리턴되는 경우에는 역시 문제없이 컴파일되고 직접 돌려서 해당 기능이 오작동을 하기 전까지 버그를 알아챌 수조차 없게 된다. 이 때문에 ==
                                            사용시 lvalue에 일부러 상수항을 사용하는 프로그래머들도 있다. 예를 들어, #int a = 42; if(a == 37) { ... } 같은
                                            경우, 실수로 if(a = 37) 이라 쓰면 false가 아닌 true가 뜨며(a = 37 이라는 expression의 값은 37 이고 0 이
                                            아닌 값은 죄다 true로 간주된다.), a에 37 이 대입돼버려 완전히 오작동을 하게 된다. 문제는, 컴파일이 문제없이 되어서 버그 찾기가
                                            더더욱 힘들어진다. 상수항을 왼쪽으로 옮겨서 if(37 == a) 로 써주면, 37 = a라 썼을 때 당연히 말이 되지 않으니 컴파일 시 에러가
                                            떠서 쉽게 알아챌 수 있다... 라는 유명한 팁이 있지만, 사람의 직관과 맞지 않아 어색하게 느껴지기 때문에 일부러 익숙해지지 않으면 잘 쓰이지
                                            않는다. 요새는 컴파일러가 좋아져서 이런 위험코드는 대체로 경고처리해준다.</li>
                                        <br>
                                        <li>배열과 포인터의 차이가 비직관적이다. 사실 이 부분이 C언어를 배우는데 가장 커다란 난관이 되는 부분이다. 배열과 포인터는 비슷하다고
                                            보기에는 차이가 너무 크고, 다르다고 보기에는 비슷한 부분이 너무 많다고 생각하는 경우가 많다. 덕분에 교재마다 접근방법이 달라지는데, 어떤
                                            교재에서는 '비슷하다'고 전제한 뒤 차이점을 설명하는 식이고, 어떤 교재에서는 '다르다'고 전제한 뒤 공통점을 설명하는 식이다. 어느 쪽으로
                                            접근하더라도 함정과 예외가 상당히 많아지기 때문에, 둘의 차이를 충분히 구분할 만한 상황적 경험이 적을 수밖에 없는 초심자들에게 결국은 이해보다
                                            암기로 흘러가고, 어렵게 느끼는 경우가 많다. 배열 타입과 포인터 타입의 차이를 제대로 느끼지 못하는 상황은 배열 타입을 식에서 이용할 때
                                            첫번째 원소를 가리키는 포인터로써 사용된다는 규칙을 제대로 숙지하지 못한 상황에서 배열과 포인터를 사용할 때 주로 발생한다. 즉, 식에서 배열
                                            타입을 이용할 때, 실제로는 배열 타입이 아닌 포인터 타입으로써 이용이 되는데 프로그래머가 이를 배열 타입을 이용하는 것으로 착각하면 "읭
                                            포인터 타입하고 많이 비슷하네?"라는 반응을 보이게 되는 것이다. 이렇게 겉으로 보기에는 배열 타입이지만 실제로는 포인터 타입으로써 사용될 수
                                            있는 비 직관적인 요소가 존재한다.</li>
                                        <br>
                                        <li>숫자 타입을 처리하는 규칙들이 비직관적이고 복잡하다. 덕분에 언어 자체의 syntax/semantics를 넘어서 이에 대한 여러가지
                                            꼼수와 내부적으로 처리하는 방식, 머신따라 달라지는 부분까지 염두에 두어야 한다. 숫자타입과 관련된 문제들은 한두가지들이 아니므로 하위 항목으로
                                            분류한다.</li>
                                        <br>
                                        <ul>
                                            <li>C언어에서는 int형과 double형만 존재하는 것처럼 느껴질 수 있는데, 실제로, 모든 리터럴은 뒤에 f 등의 타입을 붙여주지 않으면
                                                그냥 int 아니면 double이다. char건 true/false 값이건 short 건 그냥 다 int로 간주한다. 그리고, 타입변환이 필요할
                                                때마다 정수 진급(integral promotion, C99에선 integer promotion)이라 해서, char, short 등의 타입은
                                                일단 먼저 int로 바꾸고 나서 변환을 시작한다.</li>
                                            <br>
                                            <li>bool 타입은 존재하지 않으며, 0은 false이고, 나머지 다른 것들은 전부 true로 처리한다. 때문에 임의의 char 값이
                                                숫자인지 알아보는 isdigit 함수는 숫자가 아니면 0을 리턴하고 숫자일 경우 보통 1을 리턴하긴 하지만, 0이 아닌 그냥 어떤 수를 리턴하는
                                                컴파일러도 있다. 매뉴얼페이지에는 보통 non-zero라고 되어 있다(...). 비슷하게 논리적 부정 연산을 의미하는 !의 경우는 0일 경우
                                                1로, 0이 아닌 다른 모든 값은 0으로 바꾼다.</li>
                                            <br>
                                            <li>unsigned 타입이 섞인 계산에서는 음수가 양수가 되어버린다. 이 문제에 대해서는 다소 긴 설명이 필요하다. C 언어에서는 사칙연산과
                                                비교연산자를 포함하여 많은 이항연산자들이 있는데, 이것들은 서로 다른 타입간에 이루어지는 계산을 처리하기 위해 usual arithmetic
                                                conversions라는 공통규칙을 적용한다. 그런데 이 규칙에 의하면, 같은 랭크(숫자 타입의 우선순위. 간단하게는 size라 생각해도
                                                무방하다)인 부호형 정수와 무부호형 정수 사이에는 무부호형이 우선권을 가지며, 따라서 이항연산자의 두 항이 모두 무부호형으로 처리된다. 이
                                                간단한 규칙이 불러오는 참극인 즉슨, unsigned 타입이 수식 중에 단 하나라도 섞여 있으면 그 안에 포함된 모든 음수가 양수로 변해버린다.
                                                (절대값이 아니라 mod 연산된 값으로 변한다. 경고나 에러 메시지 없이.) 그 결과 일반적인 수학 수식과는 전혀 동떨어진 이상한 결과가
                                                나온다. 이를 방지하기 위해서는 그보다 더 랭크가 높고 실제 표현 범위도 큰 유부호 정수형으로 강제 형변환을 해야 한다. (혹은
                                                unsigned형을 signed형으로 형변환한다.)</li>
                                        </ul><br>
                                        <li>네임스페이스를 지원하지 않는다. 소스 수준에서 play_sound라는 함수를 어디엔가 정의를 해놓고 다른 소스 파일에서는
                                            play_sound라는 이름만 같은 다른 함수를 만들고 같이 컴파일하면 에러가 난다. 더욱 골때리는건, 컴파일 단계는 무사히 진행되는데 링커
                                            수준에서 에러가 난다는 것. 따라서, 외부 소스 파일로 노출시키고 싶지 않은 내부 함수들은 static 지시자를 앞에 붙여줘서 이름 유출을
                                            방지하고 다른 소스에서 쓸만한 함수는
                                            <모듈이름>_함수이름(e.g. NamuWiki_add_document)을 사용하여 이름 충돌을 최소화 하는게 일반적이다. 이는 사실 장점이자
                                                단점인데, C++에서는 컴파일된 심볼명에 개별 지시자를 넣어 다른 네임스페이스나 클래스의 함수 등이 충돌이 일어나지 않으나, 문제는
                                                <a href="https://namu.wiki/w/C%2B%2B">C++</a>
                                                표준에는 이 Naming Mangling에 대한 표준이 정의되어 있지가 않아 컴파일러 마다 호환이 되지 않는다. 그러나 C는 이러한 네이밍을
                                                하지 않기 때문에 컴파일러 호환성 유지가 가능한 한가지 방법이며, 이 경우
                                                <a href="https://namu.wiki/w/C%2B%2B">C++</a>로 구현되어 있으나 외부 API를 제공하는 경우 C 형 네이밍 스킴을 사용한다.</li>
                                            <br>
                                            <li>기타 비직관적이거나 혼동하기 쉬운 규칙들을 아래에 정리하였다. 이런 규칙들은 대개 성능을 위해 포기한 부분이거나, 예전부터 이어진 전통인
                                                경우가 많다.</li>
                                            <br>
                                            <ul style="line-height:25px">
                                                <li>가변함수의 매개변수에는 기본 인자 진급(default argument promotion)이 적용된다.</li>

                                                <li>함수의 매개변수로 선언된 배열은 배열이 아닌 포인터이다.</li>

                                                <li>함수 인자의 평가 순서는 정해져 있지 않다.</li>

                                                <li>피연산자 간의 평가 순서는 대체로 정해져 있지 않다. (&&나 || 등의 연산자는 예외)</li>

                                                <li>부호형과 무부호형을 섞어 쓴 수식의 형변환 규칙
                                                    <a style="color:green" href="http://minjang.egloos.com/2697619">참조 사례</a>
                                                </li>

                                                <li>시퀀스 포인트(sequence point)와 관련된 객체 변경 규칙</li>
                                            </ul><br>
                                    </ul>
                                </p>
                                <p>
                                    C 언어에는 저런 함정들이 매우 많이 도사리고 있으며, C 언어를 배운다는 것은 사실 '어떻게 프로그램을 만들것인가' 를 배우는 게 아니라,
                                    '어떻게 저런 함정을 피해갈 것인가' 를 배우는 거라는 사람도 있다.
                                </p>
                                <p>
                                    위에 나온 대부분의 단점들은 한마디로 인간이 자연스럽게 쓰기 힘들다는 것인데, C의 컨셉이 그런 것이니 당연한 것이다. 인간인 프로그래머와의
                                    친화가 우선이 아니라 컴퓨터와의 친화가 우선인 언어인 것이다. C와 컴퓨터 및 운영체제의 이해가 깊어지다 보면 왜 이렇게 쓰기 불편하게
                                    만들어진게 사실 당연한 선택이었는지 이해가 간다.
                                </p>
                                <p>
                                    그래서 조금 불편하지만 반대로 이 때문에 저레벨상에서 더 유연한 프로그래밍을 할 수 있다. 오히려 다른 언어는 변수 타입이나 참조 등에 제약이
                                    많아 저레벨 프로그래밍을 할 때는 C언어보다 더 불편한 면이 있다. 예를 들어서 블록 암호화같이 비트/바이트 단위로 바이너리를 자유자재로
                                    조작해야 하는 코드는 고수준 언어로 짜기 불편하다. 익숙해지면 구조체 같은 사용자 정의 데이터 타입을 이리저리 캐스팅해서 포인터 연산을 활용해
                                    전혀 엉뚱한 데이터로 변환해서 쓰는 것도 가능하다.
                                </p>
                                <p>
                                    사실, 초창기 C 언어는 비교적 사용하기 편리한 고수준 언어로 분류되었고 그렇기 때문에 큰 인기를 끌었지만, 오늘날 C 언어는 오히려 불편한
                                    언어에 속한다. 그럼에도 불구하고 많이 사용되는 이유중 하나는 투명성이다. 고수준 언어들의 경우, 하드웨어로부터 거의 완전히 추상화를 시킨
                                    경우가 많기 때문에 프로그램 로직에만 신경쓰면 된다는 장점이 있지만, 그게 정확히 컴퓨터에서 어떤식으로 돌아가는지를 예측하기는 그 추상화
                                    수준만큼 힘들어지게 된다. 반면, C 언어는 기능 자체가 적고 하드웨어에 맞춤형태로 최소한도의 추상화만 시킨 수준이기 때문에, 어셈블리어와의
                                    호환성도 좋고 코딩과 동시에 실제 어떤식으로 하드웨어가 움직일지 예상이 비교적 쉽다.
                                </p>
                                <p>
                                    그렇기 때문에 C 언어로 코딩을 한다는 것은 곧 저런 장점을 살리고 싶다는 것이고, 그러려면 결국 컴퓨터 아키텍처에 대한 지식도 필요하며, C
                                    언어 자체에 대해서도 아주 디테일한 수준까지 알고 있어야 한다. 이런 측면 때문에 복잡한 기능들을 많이 제공하는 고수준 언어들에 비해 쉽다고
                                    보긴 힘들다.
                                </p>
                            </div>
                            <div id="s2-3">
                                <br>
                                <strong class="Sname">
                                    <a href="#main">&nbsp;&nbsp;2.3</a>
                                    사용 분야</strong><br>
                                <hr>
                                <p>
                                    C언어는 다음과 같은 분야에서 사용된다.
                                </p>
                                <ul style="line-height:25px">
                                    <li>
                                        <a href="https://namu.wiki/w/%EC%9A%B4%EC%98%81%20%EC%B2%B4%EC%A0%9C">운영 체제</a>
                                        및 디바이스 드라이버</li>
                                    <li>
                                        <a
                                            href="https://namu.wiki/w/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC">마이크로컨트롤러</a>
                                    </li>
                                    <li>
                                        <a
                                            href="https://namu.wiki/w/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%EC%8B%9C%EC%8A%A4%ED%85%9C">임베디드 시스템</a>
                                    </li>
                                    <li>
                                        <a href="https://namu.wiki/w/%EC%95%94%ED%98%B8%ED%95%99">암호학</a>
                                        라이브러리</li>
                                    <li>프로그래밍 언어 인터프리터(<a href="https://namu.wiki/w/Python">CPython</a>
                                        등)</li>
                                    <li>웹 서버(<a href="https://namu.wiki/w/Apache">Apache</a>
                                        등)</li>
                                    <li>
                                        <a
                                            href="https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">데이터베이스</a>(<a href="https://namu.wiki/w/PostgreSQL">PostgreSQL</a>
                                        등)</li>
                                    <li>
                                        <a
                                            href="https://namu.wiki/w/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98">애플리케이션</a>
                                    </li>
                                    <li>이외에 매우 빠른 계산속도가 필요한 프로그램이나 라이브러리</li>
                                </ul>
                                보면 알겠지만 어플리케이션 레벨 프로그래머에게는 어느 하나 쉬운 분야가 없다.
                            </p>
                        </div>
                        <div id="s2-4">
                            <br>
                            <strong class="Sname">
                                <a href="#main">&nbsp;&nbsp;2.4</a>
                                이식성</strong><br>
                            <hr>
                            <p>
                                C언어 입문서를 보면 C의 주요 장점으로 이식성을 들고 있다. 그러나 쓰다보면 이 이식성은 정말로 체감하기 힘든 부분인데, 모든 플랫폼에서
                                동일한 가상 머신을 제공하는 Java는 커녕, 풍부한 자체 내장 라이브러리를 제공하는 Python 등의 스크립트 언어와 비교를 해봐도 딱히
                                이식성에 유리할 만한 부분이 없다. 그렇다고 이식성이 없는 것이냐 하면 그건 아니다. 가장 많은 플랫폼에서 지원하는 언어는 C언어이고, 어떤
                                아키텍처가 나와도 가장 먼저 지원하는 언어는 거의 대부분 C이다. 따라서 C언어의 이식성이란 것은 Java나 기타 언어들의 이식성과는 좀 다른
                                관점에서 바라볼 필요가 있다.
                            </p>
                            <p>
                                모든 프로그래밍 언어는 추상적인 개념 위에서 돌아간다. 좀 더 정확히는 프로그래밍 언어 자체가 실제가 아닌 추상적 개념이다. (이것은
                                C언어조차도 예외는 아니다.) 그런데 프로그래밍 언어에 의해 형성된 추상화 계층은 각각의 하드웨어와는 완벽하게 일치하지가 않는다. Java와
                                같은 언어는 그 하드웨어와 추상화 계층과의 차이를 가상머신으로 메워버린다. 그래서 코드 레벨에서 거의 완벽한 이식성을 확보할 수가 있다.
                                일반적으로 프로그래머들이 기대하는 이식성이란 바로 이런 코드 자체의 이식성이다.
                            </p>
                            <p>
                                C언어의 이식성은 약간 다르다. C언어의 추상화 계층은 Java의 두터움과는 달리 정말로 얇다. 그러면 필연적으로 각각의 하드웨어/아키텍처에
                                의한 차이는 고스란히 프로그래머에게 전달될 수밖에 없다. 그렇다고 이 추상화 계층을 두껍게 해 버리면 기존 legacy들과의 호환성 문제는
                                둘째치고 성능상 큰 손해를 보게 된다. 그러므로 여기서 등장하는 것이 표준문서이다. 하드웨어/아키텍처에 의한 차이가 발생하는 부분을 3단계로
                                나누어, 프로그래머가 '알아서' 대응하도록 한다. 그러면 프로그래머는 이식성 문제가 제시된 부분만 알면 되고, 컴파일러 제작자는
                                구현체(implementation) 만들기 쉬워서 좋고, 이런 저런 서로간의 타협이 이루어지게 되는 것이다.
                            </p>
                            <p>
                                C언어에는 이식성이 있는 것일까? 구현체(implementation) 자체의 이식성은 굉장히 좋다. 다양한 아키텍처를 배려하여 잘 정의된
                                표준문서로 인한 이론적 이식성과 함께, 기존의 풍부한 컴파일러 구현체 및 공개된 소스코드들이 실질적인 이식성까지 함께 확보해 준다. 그렇다면
                                코드의 이식성은 어떨까? 전적으로 프로그래머의 역량에 달린 일이겠지만, 그걸 제외하고 생각한다면 좋다고 봐야 할 것이다. C언어 자체만 '잘
                                알고 짜면' 코드가 의도한 것과는 '다르게' 작동하는 일은 없다. 그러면 프로그래머 입장에서 체감 이식성은? 유감스럽게도 매우 낮다. 기본
                                제공되는 표준 라이브러리는 그 기능이나 종류가 극히 제한적이라서 그것만 가지고서는 할 수 있는 일이 거의 없고, 추가적으로 다른 라이브러리나
                                API를 쓰게 되면 이식성이 추가된 부분들에 의해 제한받게 된다.
                            </p>
                            <p>
                                결국 'C언어'라는 공통 분모는 지극히 표준적인 사양의 동일한 물건이지만, 그것만 써서 프로그램을 작성하는 사람은 없고, 그 겉에 붙는 추가적인
                                부분들이 이식성을 제한하기 때문에, 결국 프로그래머가 체감할 수 있는 이식성은 없다고 봐야 한다.
                            </p>
                            <p>
                                다음은 단점 항목에서 분리된 이식성 관련 항목들이다.
                            </p>
                            <p>
                                C의 이식성 문제는 굉장히 까다롭다. 많은 C 입문서에서 첫머리에 C의 장점으로 '이식성이 있다'고 적어놓고 있는데, 이건 사실 프로그래머가
                                관련 내용들을 정확히 알고 있는 상태에서 코드를 주의깊게 작성했을 때에만 누릴 수 있는 장점이다. 한편, C에서 기본 제공하는 표준 라이브러리는
                                그 기능이나 종류가 극히 제한적이기 때문에, 실질적으로는 다른 API나 라이브러리에 많이 의존하여 프로그램을 작성하게 되는데, 이런 API나
                                라이브러리들은 특정 플랫폼에 종속되는 경우가 많아서, 결국 C의 이식성은 여러모로 체감하기 어렵다.
                            </p>
                            <p>
                                C언어 표준의 이식성과 관련된 부분들은 크게 3단계로 구분된다. 동작의 내용을 분명하게 명시해야 하는
                                것(implementation-defined), 동작을 보장하되 그 내용을 명시할 필요가 없는 것 (unspecified)', 동작을 보장할
                                필요가 없는 것(undefined). 이러한 것들을 표준문서에서는 Portability issues란 이름의 부록으로 따로 정리해 두고 있는데,
                                이식성을 보장받기 위해서는 자신이 프로그래밍하는 상황과 관련된 이식성 문제들을 모두 이해하고 코드를 작성해야만 한다.
                            </p>
                            <p>
                                여기서 특히 undefined에 대한 오해가 큰데, 그냥 단순히 정의되지 않는 것이라기 보다는, 거의 대부분 그냥 잘못된 코드이다. 단, C언어
                                표준 이외의 어떤 '약속'에 의해서 정상 동작을 보장하는 경우가 가끔 있기는 하다. (가장 유명한 예로는 POSIX 환경에서 동적 라이브러리를
                                호출할 때 사용하는 dlsym 함수가 있는데, 이 함수의 리턴값인 void*타입을 함수 포인터로 사용하는 것은 C99 표준상으로는
                                undefined이다.)
                            </p>
                            <p>
                                특정 기종(주로 x86 혹은 AMD64)에서만 프로그래밍을 하는 많은 프로그래머들은 이식성 문제가 자신과는 전혀 상관 없다고 생각하기 쉬운데,
                                16->32비트, 혹은 32->64비트 전환기에 많은 사람들이 실제로 고생했던 부분이며, 단순히 컴파일러의 버젼업만으로도 이런 이식성 문제들은
                                갑자기 튀어나올 수 있다. 즉, 아주 기본적인 이식성 주제들에 대해서는 알고 있어야 한다.
                            </p>
                            <p>
                                다음은 이식성과 관련된 몇 가지 예이다.
                            </p>
                            <p>
                                <ul style="line-height:25px">
                                    <li>int의 크기는 하드웨어에 따라 제각각이다. 실제로는 '해당 환경에서 가장 빠르게 접근할 수 있는' 크기로 결정된다. 대체로 해당
                                        아키텍처의 비트 수를 따라가는데,
                                        <a href="">x86</a>이나
                                        <a href="">x86-64</a>만 지원한다면 문제는 없겠지만 그 외의 환경을 생각하면 아키텍처에 따라 다른 크기가 선택될 수도 있다.</li>
                                </p>
                                <p>
                                    <ul>
                                        <li>
                                            이 문제를 해결하기 위해 C99부터 고정 크기 정수형을 지원한다. stdint.h 헤더를 포함하는 것으로 접근할 수 있으며, 형식은
                                            `int비트수_t`와 같다. 무부호형은 `uint비트수_t`. 추가로 위에서 언급한 '가장 빠르게 접근할 수 있는 크기'를 좀 더 명확히
                                            나타내는 `(u)int_fastBIT_t`도 추가되었다.</li>
                                    </ul>
                                </p>
                                <p>
                                    <li>사칙연산을 비롯한 많은 이항연산자에 대해, 각 항의 평가 순서는 정해져 있지 않다(unspecified). 앞의 항부터 먼저 할 수도
                                        있고, 뒤의 항부터 먼저 할 수도 있고, 심지어 상황에 따라 다르게 적용하거나 랜덤하게 할 수도 있다. 많은 사람들이 c = a + b 에서
                                        a와 b의 평가 순서가 정해져 있지 않다는 사실에 당황하는 사람이 많은데, 이렇게 각 구현체에게 선택의 자유를 줌으로써 각각의 환경에 맞는 가장
                                        효율적인 최적화를 가능하게 하는 것이다. (c = f1() + f2()와 같은 코드가 있을 때, 함수 f1이 먼저 실행될 지 함수 f2가 먼저
                                        실행될 지, 심지어 여기에 어떤 일관성 있는 법칙이 있을지 없을지조차도 확실하지 않다는 뜻이다)</li>
                                </p>
                                <p>
                                    <li>
                                        <a style="color:green" href="">Sequence Point</a>: 위와 비슷해 보이면서도 실제로는 전혀 다른 주제가
                                        한가지 있는데, 각 코드의 부수효과(side effect. 메모리 안 변수의 값이 실제로 변경되는 시점과 같은 것들)의 평가 순서는 정해져 있지
                                        않으며, 그것이 적용되는 시점 또한 정해져 있지 않다. 다만 확실하게 완결되는 것이 보장되는 시점(예를 들어 함수 인자의 마지막 ')'라거나
                                        수식의 끝을 알리는 ';'와 같은 지점들)이 있는데, 이를 sequence point라고 한다. 예를 들어, j = (i++) +
                                        (++i);에서 j에는 어떤 값이 대입될까?
                                        <a style="color:green" href="">이건 'undefined'다.</a>
                                        (i++)와 (++i) 중 어느 쪽이 먼저 실행되는지 부터가 위에서 말한 대로 unspecified인 사항인데, 실제 문제는 거기에서 그치지
                                        않고 더 심각하다. 언제 i를 CPU 캐시나 레지스터로 불러오거나 쓰고 실제 메모리상의 i의 값을 언제 참조하고 변경되는지조차 확실하지 않기
                                        때문에, 실제 생길 수 있는 결과는 예측 불가능이다. 그리고 이것이 두 sequence point 사이에서 동일 객체를 두번 이상 수정(또는,
                                        한번 수정하고 한번 이상 참조하는 것)하는게 undefined로 금지된 이유이다.</li>
                                </ul>
                            </p>
                            <p>
                                그러나 이런 설명은 어디까지나 21세기의 프로그래밍 환경에서 보는 관점이다. C가 이식성이 좋다는 것은 원래 어셈블리어와 비교해서 나온 말이므로
                                사실 Java 같은 언어와 비교해서 이식성을 논하는 것은 원래의 의미와는 다르게 된다. 물론 C의 전성기에도 포트란이나 PL/1 과 같은 다른
                                고급언어들이 있었고 코드 자체의 이식성만으로는 이들 언어도 C보다 뒤떨어질 게 없었지만, C는 다음의 두 가지 측면 때문에 이식성 면에서 명성을
                                얻게 되었다.
                            </p>
                            <p>
                                <ul>
                                    <li>C는 OS의 구현이 가능할 정도로 저수준의 프로그래밍이 가능하다. 포트란이 아무리 이식성이 높다고 해도 실제로 사용하지 않는다면 의미가
                                        없다. 용도가 수치계산으로 국한된 포트란이나 속도가 상관없는 분야에서만 사용할 수 있는 인터프리터 언어 등에 비해 C는 거의 모든 용도에서
                                        사용할 수 있었다. 또한 기능이나 성능이 제한적인 언어들은 일부 기능을 어셈블리어로 직접 구현해야 하는 경우가 있었는데, C는 이런 문제가 거의
                                        없었다.</li>
                                </p>
                                <p>
                                    <li>PL/1 이나 많은 인터프리터 언어들은 C만큼 많은 시스템에 구현되지 않았다. 해당 언어가 '모든 시스템에 구현된다면 높은 이식성이
                                        있겠지만' 실제로 사용할 수 있는 시스템이 제한되는 경우 이식성이 좋다고 할 수 없다. C는 거의 모든 시스템에서 사용할 수 있었기 때문에
                                        이식성을 장점으로서 누릴 수 있었다.</li>
                                </ul>
                            </p>
                            <div id="s2-5">
                                <br>
                                <strong class="Sname">
                                    <a href="#main">&nbsp;&nbsp;2.5</a>
                                    점유율과 플랫폼별 지원 현황</strong><br>
                                <hr>
                                <p>
                                    오랜 시간동안
                                    <a href="java.html">Java</a>와 함께 몇년째 1, 2위를 다투고<strong>있었다</strong>., 그 이외의언어와는넘사벽의 비율을 보여준다. 그야말로 부동의 원투펀치. 다른 언어들이 3위 경쟁을 하는 동안 C와 Java가 양대산맥을 형성하고 있다. 좀더넓게 C 계열(C++,C# 등 C 문법 혹은 그와
                                    <strong>매우</strong>
                                    유사한 문법체계를 사용하는 언어)와 JAVA 계열 (Arduino 등 JAVA 문법 혹은 그와
                                    <strong>매우</strong>
                                    유사한 문법체계를 사용하는 언어)로 보자면 C 계열이 단연코 확고한 1위. (C와 C++, C#만 합쳐도 1/3이다(...) 거기에 자바와
                                    파이썬의 점유율을 합치면 거의 절반.)
                                </p>
                                <p>
                                    가장 널리 쓰이는 PC 플랫폼인
                                    <a href="https://namu.wiki/w/Microsoft%20Windows">윈도우</a>에서는 안타깝지만 반쯤은 버려진 언어이기도
                                    하다. MS에서는 C를 Internal language로 규정하여 내부적으로 윈도우와 기타 MS 상품들을 만드는데는 사용하지만, C 프로그래밍
                                    환경을 사용자에게 정식으로 제공하지는 않는다. 덕분에 윈도우가 자랑하는
                                    <a href="https://namu.wiki/w/Visual%20Studio">Visual Studio</a>에도 C 프로젝트 항목은 없다.
                                    (C++ 프로젝트를 선택하여 소스파일 확장자를 .c로 바꿔주거나 C로 컴파일한다고 프로젝트 옵션을 설정해야 한다.) 게다가, 그런 식으로 사용을
                                    하더라도 MS의 C 지원은 순수하게 C++에 묻어가는 정도라, 새로운 ISO 스탠다드인 C99/C11의 기능들도 거의 지원하지 않으며, 앞으로의
                                    계획도 C99/C11을 완전히 지원할 예정은 전혀 없고 C99/C11의 기능 중 C++98/C++11에도 포함되는 것만 지원할 예정이다.
                                </p>
                                <p>
                                    <a href="https://namu.wiki/w/Linux">리눅스</a>의 경우에는
                                    <a href="https://namu.wiki/w/GCC">GCC</a>라는 사실상의 오픈소스 표준 컴파일러 덕분에 지원이 괜찮으며,
                                    Unix-like 운영체제라는 버프도 있고, C를 배우고 여러가지 시험해보면서 놀기에 적합한 환경을 제공해준다. 윈도우와 다르게 커널부터
                                    오픈소스로 개발되고, 이 커널이 C 언어로 만들어져 있어 C 언어의 사용도 활발하다. 이쪽 프로그래머들은 개발환경을
                                    <a href="https://namu.wiki/w/vim">vim</a>이나
                                    <a href="https://namu.wiki/w/Emacs">Emacs</a>로 사용하는 사람들이 많이 있다.
                                </p>
                                <p>
                                    <a href="https://namu.wiki/w/macOS">macOS(구 OS X)</a>는 신생 컴파일러인
                                    <a href="https://namu.wiki/w/LLVM">LLVM</a>/<a href="https://namu.wiki/w/Clang">Clang</a>을사용하며,역시 지원은 좋은 편이다. 이는 플랫폼 메인 개발언어를 Objective-C로 잡았기 때문인데, Objective-C는 C 언어와완전히 호환이되기 때문에 달랑 Objective-C만 지원해도 C가 완전히 지원되는 셈. 새로운 스탠다드의 적용도 세 플랫폼 중 가장 빠르다.MS는 위에서이야기했듯이 C++의 subset인 부분에 한해서만 C의 최신 표준을 지원하고, GCC와 LLVM/Clang은 C11을 모두지원한다.
                                </p>
                            </div>
                            <div id="s2-6">
                                <br>

                                <strong class="Sname">
                                    <a href="#main">&nbsp;&nbsp;2.6</a>
                                    다른 프로그래밍 언어에 미친 영향</strong><br>
                                <hr>
                                <p>
                                    <ul style="line-height: 25px;">
                                        <li>{ ... }을 이용한 블럭 (ALGOL/PASCAL 스타일의 begin ... end 보다 간결하다.)</li>
                                        <li>'대입'을 뜻하는 연산자를 '='로, '동일함'을 뜻하는 연산기호를 '=='로 사용한다. 농담 좀 섞어서, 초심자의 C언어 컴파일 오류의
                                            90%는 여기서 나온다.</li>
                                        <li>다르다를 뜻하는 연산기호를 !=로 사용한다.</li>
                                        <li>또는과 그리고를 ||와 &&로 사용한다.</li>
                                        <li>+=, -=, *=, /=등의 직관적인 복합연산자를 지원한다.</li>
                                        <li>++ 와 -- 라는 단항연산자를 사용한다. **와 //는 없다. **은 이중 포인터이고, //은 주석이다. 어차피 수에 1을 곱하거나
                                            나누어도 변함은 없다.</li>
                                        <li>그 외에 if, for, while 등 많은 예약어의 사용 방식.</li>
                                    </ul>
                                </p>
                                <p>
                                    어떤 의미에서는
                                    <strong>프로그래밍 언어의
                                        <a href="https://namu.wiki/w/%EB%9D%BC%ED%8B%B4%EC%96%B4">라틴어</a>/<a href="https://namu.wiki/w/%ED%95%9C%EC%9E%90">한자</a>
                                    </strong>라고 할 수도 있을지도 모른다. 현재 많은 주요 언어에서 { }를 이용한 블럭 표기나 C에서 쓰이는 표현식(==, ||,
                                    &&), 예약어(if, while) 등을 채택해서 사용하고 있다. 따라서 다른 언어를 배울 때 C언어를 먼저 배웠다면 친숙하게 느껴질 것이다.
                                </p>
                                <p>
                                    추후
                                    <a href="https://namu.wiki/w/C%2B%2B">C++</a>로 발전되었으며, C++에서는 OOP 기능을 지원한다. 다만,
                                    C언어로 OOP를 구현할 수 없는 것은 아닌데, 객체지향은 개념일 뿐이며 C로도 그 개념을 구현할 수 있다. 일례로, 당장 C 표준의 일부인
                                    파일 I/O는 객체지향이며, Win32 API나
                                    <a href="https://namu.wiki/w/Linux">리눅스</a>의 VFS(가상 파일 시스템)도 이처럼 '객체지향적'으로 코딩되어
                                    있다. 다만 언어 차원에서 지원이 없기 때문에 군더더기가 늘어날 수 있다는 점은 감안하여야 한다.
                                </p>
                                <p>
                                    <a href="https://namu.wiki/w/Java">Java</a>나
                                    <a href="https://namu.wiki/w/C%23">C#</a>,
                                    <a href="https://namu.wiki/w/Objective-C">Objective-C</a>
                                    등 여러 언어들의 모태가 된다. 때문에 C를 기초로 만들어진 언어들을 흔히 C-like Language라고 부른다. 그런 이유로 C를 제대로
                                    익히고 나면 C-like 언어들은 쉽고 빠르게 익힐 수 있다. 단, 위에서 이미 언급했지만 C 자체는 엄청나게 어렵다. 그 대신 C나 C를
                                    모태로 한 언어를 공부하면 자연스럽게 컴퓨터와 프로그램의 작동방식에 대한 기초 지식을 습득할 수 있어 다른 언어나 프로그래밍 관련 스터디를 할
                                    때 도움이 된다.
                                </p>
                                <div id="s2-6-1">
                                    <br>
                                    <strong class="Sname">
                                        <a href="#main">&nbsp;&nbsp;&nbsp;&nbsp;2.6.1</a>
                                        <a href="https://namu.wiki/w/C%2B%2B">C++</a>와의 관계</strong><br>
                                    <hr>
                                    <p>
                                        이름의 유사성 때문에 C++를 C의 확장판 정도로 생각하는 사람들이 많다. 역사적으로 일단 C++의 시작은 C with Class에서 시작한
                                        것이 맞다. 그러나 그 이후의 변화는 C와 C++의 공통적인 부분에서도 차이점을 만들기 시작했다. 간단하게 말해서,
                                        <strong>C 기준으로 작성된 소스 코드를 그대로 복사하여 C++ 코드에 옮겨붙인 뒤 컴파일하면 문제가 발생할 수 있다</strong>는 것이다. 자세한 것은 다음 문서를 참고하자.
                                        <a
                                            style="color:green"
                                            href="http://cinsk.github.io//iso-c-diff-iso-c++/python.html">ISO C와 ISO C++의 차이</a>
                                    </p>
                                    <p>
                                        ISO C++ 17 Annex C에는 다음과 같이 ISO C와의 차이점을 설명한 항목이 따로 존재한다.
                                    </p>
                                    <p>
                                        <ul style="line-height:25px">
                                            <li>새로운 키워드</li>
                                            <li>문자상수('a')의 타입(C는 int, C++은 char)</li>
                                            <li>문자열 상수의 const 유무(C는 변경불가능한 array of char, C++은 array of const char)</li>
                                            <li>잠정적 정의(tentative definition)의 허용 여부(C는 가능, C++은 불가능)</li>
                                            <li>struct의 scope 유무(C는 struct가 scope에 해당하지 않음, C++은 scope에 해당함)</li>
                                            <li>const가 명시되었고 extern이 명시되지 않은 파일 범위(scope) 이름의 내부/외부 연결(nternal/external
                                                linkage) 여부(C는 external linkage, C++은 internal linkage)</li>
                                            <li>main 함수의 재귀적 호출 여부 및 주소 소유 여부(C에서는 가능, C++에서는 불가능)</li>
                                            <li>몇몇 지점에서의 호환되는 타입(compatible type) 허용 여부(C에서는 가능하나 C++에서는 불가능한 상황이 있음. 예를 들어
                                                내용이 같으나 태그네임이 다른 구조체와 같이)</li>
                                            <li>void *의 다른 포인터 타입으로의 형변환(C는 암묵적으로 가능, C++은 명시적으로 지정이 필요함)</li>
                                            <li>함수의 비명시적 선언(implicit declaration of function)의 허용(C는 허용, C++은 허용하지 않음)</li>
                                            <li>bool 타입에 대한 감소 연산자(decrement operator)의 허용 여부(C는 허용, C++은 허용하지 않음)</li>
                                            <li>수식 내에서의 새로운 타입 선언 가능 여부(C에서는 sizeof나 cast 수식 내에서 새로운 타입을 선언하는 경우가 있었음.
                                                C++에서는 불가)</li>
                                            <li>조건 연산자, 대입 연산자, 콤마 연산자의 결과값은 lvalue(C는 아님)</li>
                                            <li>C++에서 명시적 또는 암시적 생성자와 함께 사용되는 이전 선언문으로의 점프 금지(switch 또는 continue 등과 관련)</li>
                                            <li>C++에서 어떤 값을 리턴하게 선언된 함수에서 아무 리턴값 없이 return문을 호출하는 행위 금지(C에서 이게 가능했었나?!)</li>
                                            <li>C++에서 static과 extern 한정자는 오로지 객체 또는 함수의 이름에만 적용될 수 있음. 타입 선언에 쓰이는 것은 C++에서는
                                                잘못된 문법(C에서는 무시됨)</li>
                                            <li>C++에서 register는 storage class specifier가 아님. (C++에서는 쓰이지 않으며 단지 차후를 위해 예약됨)</li>
                                            <li>typedef 이름과 struct tag 이름의 충돌 여부(C에서는 두 이름공간(namespace)이 분리됨. C++에서는 동일함. 단,
                                                typedef struct name1 { ... } name1; 과 같은 형식은 허용)</li>
                                            <li>C++에서는 struct, class, union 등의 객체를 선언할 때 그 앞에 해당 키워드를 붙일 필요가 없음</li>
                                            <li>C++에서는 const 객체가 반드시 초기화되어야 함(C에서는 그럴 필요가 없음)</li>
                                            <li>암시적인 int의 금지 (놀랍게도 type-specifier없이 선언해도 자동적으로 int가 붙는 경우가 C에 있었던 듯)</li>
                                            <li>C++에서는 auto 키워드를 storage class specifier로서 사용하는 것을 금지함</li>
                                            <li>C++에서 열거형(enumeration type)은 오로지 동일한 열거형으로만 대입이 가능함(C에서는 그냥 정수형이면 다 대입할 수 있었음)</li>
                                            <li>C에서는 열거형의 타입은 int였으나 C++에서는 그 자신의 타입을 가짐(int가 아닐 수도 있음).</li>
                                            <li>int f()와 같이 함수인자 없이 선언된 함수는 C++에서는 인자를 받지 않는 것으로 판단함(C에서는 함수 인자 갯수를 알지 못하는
                                                것으로 처리)</li>
                                            <li>함수 선언시에 파라미터 또는 리턴 타입 부분에서 곧바로 타입을 정의하는 것 금지</li>
                                            <li>void f( struct S { int a; } arg ) {} // valid C, invalid C++</li>
                                            <li>enum E { A, B, C } f() {} // valid C, invalid C++</li>
                                            <li>C++ 에서는 old style의 함수 정의를 금함. 함수 원형 선언을 강제함. (C프로그래머들조차도 생소한 오래된 스타일의 C 함수
                                                선언 방법이 있음. 이를 금한다는 뜻임)</li>
                                            <li>C++에서는 char형 배열의 초기화 시에, 충분한 공간이 있어야 함</li>
                                            <li>char array[4] = "abcd"; // valid C, invalid C++</li>
                                            <li>C++에서는 클래스 이름이 객체, 함수 또는 다른 객체 이름을 가릴 수 있음. (C에서는 struct tag 이름이 다른 객체 또는
                                                함수의 이름을 가리지 않음)</li>
                                            <li>int형 비트필드의 타입은 반드시 signed로 강제됨(C에서는 implementation-defined)</li>
                                            <li>C++에서는 중첩된 클래스의 경우 그 범위가 클래스 내부로 한정됨. C에서는 클래스가 중첩되어 선언되었다 하더라도 동일한 범위를 가짐.</li>
                                            <li>C++에서는 typedef 이름이 한번 정의된 이후에 클래스 정의 안에서 다시 재선언되는 것이 금지됨</li>
                                        </ul>
                                    </p>
                                    <p>
                                        위의 차이점들이 쉽게 합쳐질 가능성은 그리 많지 않다. C와 C++의 근본적인 방향성의 차이 때문에 생기는 문제들(예를 들어 문자상수의 타입은
                                        어떤 것이 적절하다고 생각하는가? char? int?)인데다가, 사소해 보여도 하나하나가 수십년간 쌓인 legacy 코드들을 완전히 무의미하고
                                        위험하게 만드는 변경점들이기 때문이다. 차라리 언어를 새로 하나 만드는 것이 빠르다. [62]
                                    </p>
                                    <p>
                                        참고로,
                                        <a href="https://namu.wiki/w/Objective-C">Objective-C</a>(Objective-C++이 아니다!)의
                                        경우에는 C++와 달리 C를 완전히 포함한다. 즉 Objective-C는 C의 완전한 상위집합(superset)이다.
                                    </p>
                                </div>
                            </div>
                            <div id="s2-7">
                                <br>
                                <strong class="Sname">
                                    <a href="#main">&nbsp;&nbsp;2.7</a>
                                    포인터</strong><br>
                                <hr>
                                <p>
                                    자세한 내용은
                                    <a href="c_pointer.html">C/포인터</a>
                                    문서를 참고 하십시오.
                                </p>
                            </div>
                            <div id="s3">
                                <br>
                                <strong class="Sname">
                                    <a href="#main">3.</a>
                                    C 언어용 개발 도구들</strong><br>
                                <hr>
                                <p>
                                    <ul style="line-height: 30px;">
                                        <li>Visual Studio
                                            <a style="color:green" href="http://www.visualstudio.com/ko/">한국어 공식 사이트</a><br>
                                            마이크로소프트에서 만든 IDE. Visual Studio 2019 16.8이후 부터 C언어 표준과 C++언어 표준을 각각 지원한다.</li>
                                        <li>CLion
                                            <a style="color:green" href="https://www.jetbrains.com/clion/">공식 사이트</a><br>
                                            IntelliJ IDEA로 유명세를 날리고 있는 JetBrains에서 개발한 C/C++ IDE이다. 인터페이스가 직관적이고 다양한 종류의
                                            컴파일러로 크로스플랫폼 개발이 가능하다는 장점이 있다. CMake 기반으로 프로젝트를 생성하며, 유료 구독권 형식으로 판매되고 있기 때문에
                                            월/년마다 정기 구매해야 한다. 윈도우 환경에서 WSL에 접속하여 리눅스 기반 컴파일을 할 때 가장 편리한 툴이기도 하다. 또한 유일하게 제대로
                                            된 윈도우 환경에서의 C IDE이기도 하다.</li>
                                        <li>Xcode
                                            <a style="color:green" href="https://developer.apple.com/xcode/">공식 사이트</a><br>
                                            애플에서 직접 제작한 IDE. 예전에는 GCC를 그대로 가져다[104] 썼지만, 요즘은 LLVM이라는 새 컴파일러 셋으로 이주하였다.[105]
                                            C, C++, Objective-C, Swift 등의 언어를 컴파일할 수 있다. macOS용 애플리케이션이나 iOS용 앱을 제작하는 데는
                                            필수이다.</li>
                                        <li>Visual Studio Code
                                            <a style="color:green" href="https://code.visualstudio.com/">공식 사이트</a><br>
                                            마이크로소프트의 텍스트 에디터로, C/C++ 플러그인을 설치하면 VS와 동일한 인텔리센스가 제공된다. IDE가 아니므로 컴파일러와 디버거, 빌드
                                            툴 등을 직접 세팅해야 하지만, 그만큼 VS에 비해 가벼우므로 환경 구성법만 안다면 단순 코드 작성에는 이쪽이 나을 수 있다.</li>
                                        <li>넷빈즈 공식
                                            <a style="color:green" href="https://netbeans.apache.org/">사이트</a><br>
                                            오픈 소스 IDE 중 하나로, 원래 오라클에서 배포하였으나 2016년에 아파치 소프트웨어 재단으로 소유권이 이전되었다.</li>
                                        <li>이클립스 CDT
                                            <a style="color:green" href="https://eclipse.org/cdt/">공식 사이트</a><br>
                                            오픈 소스 IDE인 이클립스의 C/C++ 개발용 플러그인이다.</li>
                                        <li>Code::Blocks
                                            <a style="color:green" href="http://www.codeblocks.org/">공식 사이트</a><br>
                                            C/C++/Fortran용 오픈 소스 통합 개발 환경이며 라이선스는 GPL 3.0 버전을 따르고 있다.</li>
                                        <li>Bloodshed Dev-C++
                                            <a style="color:green" href="http://www.bloodshed.net/devcpp.html">공식 사이트</a><br>
                                            GPL 라이선스를 따르는 오픈 소스 IDE. 2006년 이후로는 소식이 없다. 설치 속도가 빠르고 편리하지만 리소스 에디터가 없다. 설치할 때
                                            기본적으로 같이 깔리는 컴파일러는 MinGW+GCC.</li>
                                        <li>Orwell Dev-C++
                                            <a style="color:green" href="http://orwelldevcpp.blogspot.kr/">공식 사이트</a><br>
                                            오웰(Orwell)이 Bloodshed Dev-C++ 4.9.9.2 소스로 개발하고 있는 IDE이다. 2015년 이후로는 무소식.</li>
                                        <li>Borland C
                                            <a style="color:green" href="http://edn.embarcadero.com/article/20633">지원 페이지</a><br>
                                            볼랜드에서 개발한 유료 IDE. MS-DOS 시절에는 터보 파스칼과 함께 빠른 컴파일 속도로 인기가 많았으나, 윈도우의 시대가 오면서 점차
                                            Visual Studio에 밀리게 되었다. 단순 컴파일러는 현재 무료로 다운로드 가능하다. 볼랜드가 개발언어 쪽만 전담하는 코드기어라는 자회사를
                                            설립하면서 모든 권한을 넘겼는데, 코드기어가 엠바카데로와 합병되면 홈페이지가 여러 차례 이동되었다. 참고로 델파이의 개발도
                                            볼랜드→코드기어→엠바카데로의 순서로 넘어갔다.</li>
                                        <li>Turbo C++
                                            <a
                                                style="color:green"
                                                href="https://www.developerinsider.in/download-turbo-c-for-windows-7-8-8-1-and-windows-10-32-64-bit-full-screen/">다운로드 페이지</a><br>
                                            볼랜드 Turbo C++를 Windows 7, 8, 10을 위해 확장한 버전. 그 외에는 소식이 없다.</li>
                                        <li>Watcom C
                                            <a style="color:green" href="http://www.openwatcom.org/index.php/Main_Page">공식 사이트</a><br>
                                            도스 시절 끝무렵에 DOS/4GW라는 메모리 확장 프로그램과 함께 잠깐 동안 쓰였다(8.5 버전부터 포함되었다). MS-DOS의 640KB
                                            메모리 한계를 넘어 64MB까지의 메모리를 손쉽게 사용할 수 있게 해 주었기 때문이다. 그 당시의 게이머들이라면 실행 초기에 DOS/4GW라고
                                            뜨던 안내문을 기억할 것이다. 공식 사이트가 위키 형식으로 되어 있다. Open Watcom Public License라는 라이선스를 따른다.</li>
                                        <li>LCC
                                            <a style="color:green" href="https://en.wikipedia.org/wiki/LCC_%28compiler%29">위키백과 영문</a><br>
                                            A Retargetable C Compiler: Design and Implementation라는 책에 소스 코드가 실려있는 C 컴파일러.
                                            데이브 핸슨(Dave Hanson)과 크리스 프레이저(Chris Fraser)가 만들었다. 아래에 설명하겠지만 이를 기반으로 하는 컴파일러가
                                            몇몇 존재한다.</li>
                                        <li>lcc-win
                                            <a style="color:green" href="https://lcc-win32.services.net/">lcc-win</a><br>
                                            위의 LCC를 바탕으로 한 윈도우용 C 컴파일러. 제이컵 나비아(Jacob Navia)가 만들었다. 월간 마이크로소프트웨어를 통해 국내에 소개된
                                            적이 있다.</li>
                                        <li>Pelles C
                                            <a style="color:green" href="http://www.smorgasbordet.com/pellesc/">공식 사이트</a><br>
                                            위의 LCC를 기반으로 스웨덴의 펠레 오리니우스(Pelle Orinius)가 개발한 컴파일러. 윈도우 전용의 프리웨어 통합 개발 환경이다.
                                            MS와는 다르게 C99는 물론이고, C11도 완벽 지원하는 컴파일러를 제공한다. 게다가 툴이 가볍고 무료다.</li>
                                        <li>ICC (Intel C++ Compiler)
                                            <a
                                                style="color:green"
                                                href="https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler">위키백과 영문</a>
                                            <a style="color:green" href="https://software.intel.com/en-us/c-compilers">공식 사이트</a><br>
                                            <a href=""></a>인텔에서 자기들이 만든 CPU에 최적화된 코드를 만들어 낼 수 있도록 직접 제작한 컴파일러 스위트. 사용 설명서 시작
                                            부분에 '인텔에서 제작하지 않은 CPU에서 구동 시 최적화된 성능을 보장할 수 없습니다'라고 적혀 있다.
                                            <a
                                                style="color:green"
                                                href="https://software.intel.com/en-us/articles/optimization-notice#opt-en">#</a>
                                            C/C++ 및
                                            <a href="https://namu.wiki/w/%ED%8F%AC%ED%8A%B8%EB%9E%80">Fortran</a>
                                            컴파일러를 제공한다. 윈도우에서 설치 시, Visual Studio에 애드온 형태로 설치가 돼서 Visual Studio 내에서 기존 컴파일러
                                            대신에 사용할 수 있다. 컴파일러 이외에도
                                            <a href="https://namu.wiki/w/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4">어셈블리어</a>
                                            단위로 한땀한땀 손으로 최적화한 수치해석 라이브러리<a style="color:green" href="https://en.wikipedia.org/wiki/Math_Kernel_Library">#</a>와 다수의 컴퓨터가 동시에 컴퓨팅을 할 때 사용되는 MPI 라이브러리, 코드의 성능을 분석해주는 도구<a style="color:green" href="https://en.wikipedia.org/wiki/VTune">#</a>, 코드 최적화를 도와주는 도구<a style="color:green" href="https://en.wikipedia.org/wiki/Intel_Advisor">#</a>, 성능에 악영향을 주는 에러를 찾아주는 도구<a style="color:green" href="https://en.wikipedia.org/wiki/Intel_Inspector">#</a>, 등을 하나로 묶어서
                                            <a style="color:green" href="https://software.intel.com/parallel-studio-xe">Intel Parallel Studio</a>라는 이름으로 판매한다. 인텔 CPU와 인텔 가속기를 수만 개씩 사용하는 슈퍼컴퓨터 등에서는 매우 자주 쓰이는 유용한 도구.<br>
                                            Intel Parallel Studio는 학생 대상으로 무료로 사용 가능(윈도우용은 Visual Studio 통합 포함)하고, 수치해석
                                            라이브러리는 일반인 대상으로 무료 사용 가능하다.</li>
                                    </ul>
                                </p>
                            </div>
                            <div id="s4">
                                <br>
                                <strong class="Sname">
                                    <a href="#main">4.</a>
                                    여담</strong><br>
                                <hr>
                                <p>
                                    C 언어의
                                    <a href="https://namu.wiki/w/%EC%B6%94%EC%A2%85%EC%9E%90">추종자</a>들은 다음과 같은 소리를 한다.
                                </p>
                                <div class="specialBox">
                                    <p>
                                        전산과 신입생은 CPU부터 시작해서 C를 활용하는 데까지 차곡차곡 기초를 닦아야 합니다. 저는 솔직히 너무나도 많은 컴퓨터 관련 교육과정들이
                                        자바가 가장 좋은 초보자용 언어라고 선전하는 현실에 질려 버렸습니다. 흔히 자바는 쉽고, 따분한 문자열이나 malloc과 같은 골칫덩어리를
                                        다루는 과정에서 혼란을 겪지 않으며, 아주 큰 프로그램을 모듈로 나눠서 만들 수 있는 근사한 객체지향 프로그래밍 기법을 배울 수 있다는 화려한
                                        이유들이 따라 나옵니다. 하지만 여기에는 교육적인 재앙이 있습니다. 졸업생들은 하향 평준화돼 러시아 페인트공 알고리즘을 여기저기에 만들어내며,
                                        심지어 자신의 잘못을 인식조차 못할 겁니다. 펄 스크립트에서 이런 사실을 결코 볼 수 없을지라도, (물론 어렵지만) 기본적으로 문자열이 무엇인지
                                        아주 깊은 단계에서 이해하지 못하기 때문입니다. 다른 이들이 뭔가를 잘하도록 가르치길 원한다면, 기초부터 시작해야 합니다. 이는 마치
                                        <a href="https://namu.wiki/w/%EB%B2%A0%EC%8A%A4%ED%8A%B8%20%ED%82%A4%EB%93%9C">베스트 키드</a>와 비슷합니다. 마루바닥을 쓸고 닦고 쓸고 닦고, 이렇게 3주만 하면, 자연스럽게 목표물을 향해 발이 쭉쭉 뻗어나갑니다.<br>
                                        -- 조엘 온 소프트웨어 (조엘 스폴스키)
                                    </p>
                                </div>
                                <p>
                                    C언어를 깊게 공부하면 시스템의 저수준에 대해서 이해하는데 많은 도움이 되지만, 그렇다고 해서 그것을 알아야만 잘 짜여진 프로그램을 만들 수
                                    있는 것은 아니다. 그리고 컴퓨터의 속도가 매우 빨라지고 보편화된 현대에는 고도로 추상화되고 생산성이 높은 언어에 대한 수요가 매우 크기
                                    때문에, 다른 언어를 먼저 공부하는 것도 나쁘지 않은 선택이다.
                                </p>
                                <p>
                                    다소 어렵긴 어려운지, 대학교에서 C언어를 공부하는 많은 학생들이 공부 대상과 똑같은 학점을 받는 경우가 있는 모양(...)
                                </p>
                                <div id="s4-1">
                                    <br>
                                    <strong class="Sname">
                                        <a href="#main">&nbsp;&nbsp;4.1</a>
                                        C언어의 다음 언어?</strong><br>
                                    <hr>
                                    <p>
                                        B 언어 기반으로 C 언어가 탄생하면서 한때는 프로그래머 유머로 'C' 다음 언어가 과연 'D'일지 'P'일지 묻는 이야기가 있었지만
                                        <a href=""></a>C++ 같은 것도 나왔고, ANSI C, C99,
                                        <del style="color:grey">C0x</del>
                                        C11, C18 등으로 가지를 뻗으며 진화 중인 현재의 C언어에게는 이미 과거의 이야기가 되어버렸다. 사실
                                        <strong>
                                            <a href=""></a>D</strong>라는 프로그래밍 언어도 있기는 있다.
                                        <del style="color:grey">Birth와 Death사이의 C언어</del>
                                        벨 연구소가 아닌
                                        <a style="color:green" href="http://www.digitalmars.com/">디지털 마르스</a>(Digital
                                        Mars)에서 만든 것이기는 하지만. C++와의 문법적인 호환성은 없지만 C++의 단점을 보완하면서 고생산성을 추구하는 하이 레벨 언어들의
                                        특성들을 반영한 네이티브 컴파일 언어라 사실상 C++의 리엔지니어링 버전처럼 취급하고 있다.
                                        <a href="https://namu.wiki/w/ABA%20Games">ABA Games</a>의 게임들 대부분도 D로 만든 것이다.
                                    </p>
                                    <p>
                                        잘 모르는 사실이지만 1997년에 등장한
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/E_(programming_language)">E</a>라는 프로그래밍 언어도 있다. 등장한 순서만 따지면 2001년 12월에 등장해서 2007년에 정식판이 나온 D언어보다 훨씬 먼저 나온 셈.
                                    </p>
                                    <p>
                                        그 외에 단일 영문자 이름을 지닌 프로그래밍 언어는
                                        <a
                                            href="https://namu.wiki/w/A(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)">A,</a>
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/F_(programming_language)">F,</a>
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/G_programming_language">G,</a>
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/J_(programming_language)">J,</a>
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/K_(programming_language)">K,</a>
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/P_(programming_language)">P,</a>
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/Q_(disambiguation)#Computing_and_computer_games">Q,</a>
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/R_(programming_language)">R,</a>
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/S_(programming_language)">S,</a>
                                        <a
                                            style="color:green"
                                            href="https://en.wikipedia.org/wiki/T_(programming_language)">T,</a>
                                        <a style="color:green" href="https://vlang.io/">V,</a>
                                        <a style="color:green" href="https://en.wikipedia.org/wiki/Z_notation">Z</a>가 있다.
                                    </p>
                                </div>
                                <div id="s4-2">
                                    <br>
                                    <strong class="Sname">
                                        <a href="#main">&nbsp;&nbsp;4.2</a>
                                        Write in C</strong><br>
                                    <hr>
                                    <p>
                                        C 언어와 관련해서 다음과 같은 노래도 있다. 참고로 다음 노래는 비틀즈의 Let It Be를 패러디한 것.
                                    </p>
                                    <iframe
                                        width="560"
                                        height="315"
                                        src="https://www.youtube.com/embed/XHosLhPEN3k"
                                        title="YouTube video player"
                                        frameborder="0"
                                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                        allowfullscreen="allowfullscreen"></iframe>
                                    <div class="specialBox">
                                        When I find my code in tons of trouble<br>
                                        내가 짠 프로그램에 문제가 가득하단 걸 알았을 때<br>
                                        friends and colleagues come to me,<br>
                                        친구와 동료들이 다가와<br>
                                        speaking words of wisdom...<br>
                                        슬기로운 말을 해주었네...<br>
                                        "write in C"<br>
                                        "C로 짜"<br>
                                        <br>
                                        And as the deadline fast approaches,<br>
                                        마감은 빠르게 다가오는데<br>
                                        and bugs are all that I can see<br>
                                        버그밖에 보이지 않아<br>
                                        Somewhere someone whispers:<br>
                                        어디선가 누군가가 속삭였지<br>
                                        "Write in C"<br>
                                        "C로 짜"<br>
                                        <br>
                                        Write in C, Write in C, Write in C, Write in C,<br>
                                        C로 짜, C로 짜, C로 짜, C로 짜<br>
                                        LOGO's dead and burried,<br>
                                        LOGO는 이미 죽어서 묻혀버렸어<br>
                                        Write in C<br>
                                        C로 짜<br>
                                        <br>
                                        I used to write a lot of FORTRAN<br>
                                        예전엔 포트란으로 많이 짰었어<br>
                                        For science it worked flawlessly<br>
                                        수식 계산에선 나무랄 데 없었지만<br>
                                        Try using it for Grahpics!<br>
                                        포트란으로 그래픽을 해 보라고!<br>
                                        Write in C!<br>
                                        C로 짜<br>
                                        <br>
                                        And if you've just spent nearly 30 hours<br>
                                        어셈블리 디버깅을<br>
                                        debugging some assembly<br>
                                        30시간 정도 해 봤었다면<br>
                                        Soon you will be glad to<br>
                                        금방 고마움을 느낄 거야<br>
                                        write in C<br>
                                        C로 짜<br>
                                        <br>
                                        Write in C, Write in C, Write in C, Write in C.<br>
                                        C로 짜, C로 짜, C로 짜, C로 짜<br>
                                        BASIC's not the answer,<br>
                                        베이식으론 해결이 안 돼<br>
                                        Write in C.<br>
                                        C로 짜<br>
                                        <br>
                                        Write in C, Write in C, Write in C, Write in C.<br>
                                        C로 짜, C로 짜, C로 짜, C로 짜<br>
                                        PASCAL won't quite cut it,<br>
                                        파스칼로는 부족한 걸<br>
                                        Write in C!<br>
                                        C로 짜<br>
                                    </div>
                                    <p>
                                        이 노래에 대한 또다른 패러디로,
                                        <a
                                            href="https://namu.wiki/w/Go(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)">Go</a>버전인
                                        <a
                                            href="https://namu.wiki/w/Go(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)#%EC%97%AC%EB%8B%B4">Write in Go</a>도 존재한다.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </article>
            </nav>
        </body>

    </html>